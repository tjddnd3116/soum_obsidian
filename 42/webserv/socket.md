# socket
## name
>socket - 통신을 위한 endpoint 생성

## synopsis
```c
#include <sys/socket.h>

int socket(int domain, int type, int protocol);
```

## description
- socket()은 통신을 위한 endpoint를 생성하고 그 endpoint의 참조인 파일 디스크립터를 리턴합니다.
- 파일 디스크립터는 현재 프로세스에 열려있지 않은 가장 낮은 번호의 숫자로 리턴 됩니다.
- domain 인자는 통신 도메인을 지정합니다.
- 이것은 통신에 사용한 프로토콜 패밀리를 선택합니다.
- 이 패밀리는 <sys/socket.h>에 정의되어 있습니다.

|Name|Purpose|Man page|
|-|-|-|
|AF_UNIX|로컬 통신|unix(7)|
|AF_LOCAL|AF_UNIX의 동의어||
|AF_INET|IPv4 인터넷 프로토콜|ip(7)|
|AF_AX25|아마추어 무선 AX.25 프로토콜|ax25(4)|
|AF_IPX|IPX - Novell 프로토콜||
|AF_APPLETALK|AppleTalk|ddp(7)|
|AF_X25|ITU_T X.25 / ISO-8208 프로토콜|x25(7)|
|AF_INET6|IPv6 인터넷 프로토콜|ipv6(7)|
|AF_KEY|키 관리 프로토콜|ax25(4)|
|AF_NETLINK|커널 사용자 인터페이스 장치|netlink(7)|
|AF_PACKET|Low-level 패킷 인터페이스|packet(7)|
|AF_RDS|Reliable Datagram Sockets (RDS) 프로토콜|rds(7) rds-rdma(7)|
|AF_PPPOX|L2 터널 세팅을 위한 일반 PPP 전송계층||
|AF_LLC|논리적 링크 제어(IEEE 802.2 LLC) 프로토콜||
|AF_IB|InfiniBand 기본 주소 지정||
|AF_MPLS|다중 프로토콜 레이블 스위칭||
|AF_CAN|컨트롤러 영역 네트워크 자동 버스 프로토콜||
|AF_TIPC|클러스터 도메인 소켓 프로토콜||
|AF_BLUETOOTH|블루투스 Low-level 소켓 프로토콜||
|AF_ALG|커널 암호화 API에 대한 인터페이스||
|AF_VSOCK|VMWare VSockets|vsock(7)|
|AF_KCM|커널 연결 멀티플렉서 인터페이스||
|AF_Xdp|express data path 인터페이스||

- socket() 함수의 type 인의는 통신 의미를 지정합니다.
	- SOCK_STREAM : 순차적이고, 신뢰할수 있으며 양방향의 바이트 스트림 연결기반을 제공합니다. 대역 이외 데이터 전송 메커니즘이 지원될 수 있습니다.
	- SOCK_DGRAM : 데이터 그램을 지원합니다. (연결불가능 하고 최대 고정길이의 메시지를 신뢰할수 없음)
	- SOCK_SEQPACKET : 최대 고정길이의 데이터그램을 위한 순차적이고 안정적인 양방향 연결기반 데이터 전송 경로를 제공합니다. 각각의 입력 시스템콜과 함께 모든 패킷을 읽어야 합니다.
	- SOCK_RAW : 원시 네트워크 프로토콜 엑세스를 제공합니다.
	- SOCK_DRM : 순서를 보장하지 않는 안정적인 데이터 그램 계층을 제공합니다.
	- SOCK_PACKET : 더 이상 사용되지 않으며 새 프로그램에서도 사용해서는 안됩니다.

- 리눅스 2.6.27 이후부터는 type 인자는 두 번째 목적으로 사용될수 있습니다.
- 다음의 값중 하나를 type 인자의 OR 연산을 통해 socket()함수의 동작을 변경할수 있습니다.
	- SOCK_NONBLOCK :
		- 열려있는 파일 디스크립터에 O_NONBLOCK 상태 플래그를 부여합니다.
		- 새로운 파일 디스크립터에 의해 참조됩니다.
		- 해당 플래그를 사용하면 같은 결과를 얻기위한 fcntl(2)의 호출을 하지 않아도 됩니다.
	- SOCK_CLOEXEC :
		- 새로운 파일 디스크립터에 FD_CLOEXEC 플래그를 부여합니다.
		- 이것이 왜 유용한지는 open() 의 O_CLOEXEC 플래그 설명을 참조하십시오

- protocol 인자는 소켓과 함께 사용될 특정 프로토콜을 지정합니다.
- 일반적으로 주어진 프로토콜 패밀리 내에서 특정 소켓 타입을 지원하기 위해 단일 프로토콜만 존재합니다. 이경우 프로토콜은 0으로 지정될수 있습니다.
- 하지만 많은 프로토콜이 존재할 수 있으며 이러한 경우 특정 프로토콜이 이러한 방식으로 지정되어야 합니다.
- 사용할 프로토콜 번호는 통신이 발생할 "통신 도메인"에 한정됩니다.
- 프로토콜 이름 문자열을 프로토콜 번호로 매핑하는 방법은 getprotent(3)을 참조하십시오

- SOCK_STREAM 타입의 소켓은 전이중(데이터를 동시에 양방향으로 전송) 바이트 스트림 입니다.
- 스트림 소켓은 데이터를 전송하거나 수신하기 전에 연결된 상태여야 합니다.
- connect(2)의 호출로 다른 소켓에 대한 연결이 생성됩니다.
- 연결되면 read(2) write(2)의 호출이나 일부 변형된 send(2) recv(2)의 호출을 사용하여 데이터를 전송할 수 있습니다.
- 세션이 완료되면 close(2)를 수행 할수있습니다.
- 대역 외 데이터(out-of-band) 데이터는 send(2)와 recv(2)에 설명된대로 전송되고 수신될 수 있습니다.

- SOCK_STREAM을 구현하는 통신 프로토콜은 데이터가 손실되거나 중복되지 않도록 보장합니다.
- 버퍼 공간이 있는 peer 프로토콜에 데이터의 일부가 적절한 시간 내에 성공적으로 전송될 수 없는 경우 연결이 끊긴 것으로 간주됩니다.
- 소켓에서 SO_KEEPALIVE가 활성화되면 프로토콜은 다른 쪽 끝이 여전이 활성 상태인지 프로토콜별 방식으로 확인합니다.
- SIGPIPE 신호는 프로세스가 중단되 스트림을 송수신하는 경우 발생합니다.
- 이것은 시그널을 핸들링하지 않는 프로세스는 종료되게 합니다.

- SOCK_SEQPACKET 소켓은 SOCK_STREAM 소켓과 동일한 시스템 콜을 사용합니다.
- 유일한 차이점은 read(2)의 호출은 요청된 양의 데이터만 리턴하고 도착 패킷에 남아있는 데이터는 폐기 된다는 점입니다.
- 또한 수신 데이터그램의 모든 메시지 바운더리도 보존됩니다.

- SOCK_DGRAM 과 SOCK_RAW소켓은 sendto(2)의 호출로 정해진 상대에게 데이터그램의 전송을 허용합니다.
- 데이터그램은 일반적으로 sender의 주소에 따라 다음 데이터그램을 리턴하는 recvform(2) 함수로 수신합니다.

- SOCK_PACKET은 장치 드라이버로부터 직접 raw패킷을 수신하는 구식 소켓 유형입니다.
- 그러므로 packet(7) 함수를 사용하십시오

- fcntl(2)의 F_SETOWN 동작은 프로세스를 지정할수 있습니다.
- 또는 프로세스 그룹은 대역 외 데이터 (out-of-band bata)가 도착할때 SIGURG 시그널을 받거나 SOCK_STREAM 연길이 예기치 않게 끊어질 때 SIGPIPE 신호를 받습니다.
- 이 작업은 SIGIO를 통해 I/O 및 I/O 이벤트의 비동기 알림을 수신하는 프로세스 또는 프로세스 그룹을 설정하는데 사용될 수 있습니다.
- F_SETOWN을 사용하는 것은 FIOSETOWN 이나 SIOCSPGRP 인수를 사용하는 ioctl(2) 의 호출과 같습니다.

- 네트워크가 프로토콜 모듈에 오류 상태 신호를 보낼때(예: IP에 대한 ICMP 메시지 사용) 소켓에 대해 보류중인 오류 플래그가 설정됩니다.
- 이 소켓에서 다음 작업을 수행하면 오류 코드가 반환됩니다.
- 일부 프로토콜의 경우 소켓당 오류 대기열을 활성화하여 오류에 대한 자세한 정보를 검색할 수 있습니다. ip(7)의 IP_RECVERR을 참조 하십시오
- 소켓의 작동은 소켓 레벨 옵션에 의해 제어됩니다.
- 이러한 옵션은 <sys/socket>에 정이되어 있습니다.
- setsockopt(2) 과 getsockopt(2) 함수는 이러한 옵션을 설정하고 가져옵니다.

## return value
- 성공시 새로운 소켓에 대한 파일 디스크립터가 리턴됩니다.
- 실패시 -1이 리턴되고 errno이 오류를 나타내도록 설정됩니다.

## errors
- EACCES : 지정된 유형의 소켓을 생성할 수 있는 권한 또는 프로토콜이 거부되었습니다.
- EAFNOSUPPORT : 구현이 지정된 주소 family를 지원하지 않습니다.
- EINVAL : type에 잘못된 플래그가 있습니다.
- EMFILE : 열린 파일의 총 개수가 프로세스의 한계에 도달했습니다.
- ENFILE : 열린 파일의 총 개수가 시스템 전체의 한계의 도달했습니다.
- ENOBUFS or ENOMEM : 사용 가능한 메모리가 부족합니다. 충분한 리소스가 해제될 때까지 소켓을 생성할수 없습니다.
- EPROTONOSUPPORT : 프로토콜 타입이나 지정된 프로토콜이 이 도메인을 지원할 수 없습니다.